--- 
layout: post
title: Intro to Three.js, Part 2 - Creating a Dynamic Earth-Moon System
about: Building off of our last post, we will create a more complex model of the earth-moon system.  We'll cover adding more complex objects, and introducing camera and object motion into our system.
---

In this post: 3D graphics, three.js, camera motion, simulations.

Today, we will continue to build off of earth model we created in the last post.  To see the full code for this post, check out the github repo: [github repo](https://github.com/MattLoftus/threejs-space-simulations/blob/master/examples/earth-moon-system-dynamic.html)  

####**Overview**####

1.   Add camera control via mouse movements with orbit controls.
2.   Make the earth rotate and add a cloud layer
3.   Add a starfield and the moon to the scene.
4.   Make the moon orbit the earth using polar coordinates.
5.   Demonstrate a basic flyby.

####**Orbit Controls**####
In our past example, the camera in our scene was static.  It did not rotate or move, and we couldn't change the view using the mouse.  It would be nice to make this scene interactive, and allow the user to change the camera's postion and orientation using the mouse.  Normally this would be challenging, but thanks to [@mrdoob](https://github.com/mrdoob), we have a great helper file that takes care of this for us.  First we have to be sure to add the orbit-controls.js file in our header, then add the following line after we have created our renderer and camera.

{% highlight js %}
//Orbit Controls
var orbit = new THREE.OrbitControls( camera, renderer.domElement )
{% endhighlight %}

Now we can zoom in and out and pivot the camera to view different parts of the scene.

####**Earth Rotation and Cloud Layer**####
Our model of the earth looks a bit static, so lets first give the earth a slight rotation.  In general, when we want to give our objects or our camera motion, we will do this inside of the render method.  Inside the render method, we can update the the attributes of the different objects in our scene, then when the scene is re-rendered, it will reflect those new properties.  When we create a mesh, which I'll refer to as an object, we assing it to a variable.  Using this variable, we can access different properties and methods on the object itself.  The two properties I want to focus on in this post are the postion and rotation properties.  To introduce a rotation for the earth, we will use the following syntax:

{% highlight js %}
//Render loop
var render = function() {
  //Rotate the earth about the y-axis
  earth.rotation.y -= .0005;

  renderer.render(scene, camera);
  requestAnimationFrame(render);
};
render();
{% endhighlight %}

When we think about rotations, we want to think of them as a rotation about an axis.  We want to rotate the earth in the East-West direction.  If we recall that the y axis is the vertical pointing axis in the scene, we can see that we need to rotate the earth about the y-axis to get the desired rotation.  

![y-axis-rotation](/images/rotations_diagram.jpg)

Now every time the render method is invoked, it will increment the roation by that small value.  As the render loop occurs 60 times per second, this will give us a reasonably quick rotation. (The Mars in the sidebar is nearly identical in terms of code, it just has a different texture map).

<div id="earth-rotation"></div>
<script>
  (function(){
    var width = window.innerWidth;
    var height = window.innerHeight;
    //Swap for mobile
    if (height > width) {
      var tempWidth = width;
      width = height;
      height = tempWidth;
    }
    var scene = new THREE.Scene();
    var camera = new THREE.PerspectiveCamera(45, width/height, 1, 2000);
    scene.add(camera);
    camera.position.set(0,0,30);

    var renderer = new THREE.WebGLRenderer({antialias: true});
    renderer.setSize(width/2, height/2);
    document.getElementById("earth-rotation").appendChild(renderer.domElement);

    var orbitControls = new THREE.OrbitControls(camera, renderer.domElement);

    var ambientLight = new THREE.AmbientLight(0xf1f1f1);
    scene.add(ambientLight);
    var spotLight = new THREE.DirectionalLight(0xffffff);
    spotLight.position.set(50,50,50);
    scene.add(spotLight);

    var earthGeometry = new THREE.SphereGeometry(10, 50, 50);
    var earthMaterial = new THREE.MeshPhongMaterial({
      map: new THREE.ImageUtils.loadTexture("/images/earth_3.jpg"),
      color: 0xf2f2f2,
      specular: 0xbbbbbb,
      shininess: 2
    });
    var earth = new THREE.Mesh(earthGeometry, earthMaterial);
    scene.add(earth);

    var render = function() {
      earth.rotation.y -= .0005;
      renderer.render(scene, camera);
      requestAnimationFrame(render);
    };
    render();
  })();
</script>

Adding some motion gives our graphic a lot more value, lets take it a step further by adding a cloud layer to the scene, and giving it a rotation speed slightly different than that of the earth itself.  The way we will impement the cloud layer will be to create a new sphere object, with a radius slightly larger that that of the earth.  Lets jump into the code and go over the details afterwards.

{% highlight js %}
//Cloud Geomtry and Material
var cloudGeometry = new THREE.SphereGeometry(10.3,  50, 50);
var cloudMaterial = new THREE.MeshPhongMaterial({
  map: new THREE.ImageUtils.loadTexture("/images/clouds_2.jpg"),
  transparent: true,
  opacity: 0.1
});

//Create a cloud mesh and add it to the scene.
var clouds = new THREE.Mesh(cloudGeometry, cloudMaterial);
scene.add(clouds);
{% endhighlight %}

As we can see, adding the cloud layer is quite similar to creating the earth.  We first create a sphere geometry with a radius of 10.3 (the earth is 10).  Next, we create a MeshPhongMaterial, only this time we wrap a cloud texture map around the sphere.  The other two properties in the material are critical.  First we set the transparent boolean property to true, otherwise it would completely mask the earth sphere.  We then give the material an opacity value of .1 (out of 1), meaning it is mostly transparent.  Any value between about 0.05-0.2 will look reasonable.  The last thing we have to do is build the mesh, assign it to the variable clouds, and add it to the scene.

We should add a rotation to the clouds before we move on.  In reality, the clouds rotation would be quite complex, but for the sake of demonstration, we'll just make the clouds rotational speed half that of the earth's.

{% highlight js %}
//Render loop
var render = function() {
  //Rotate earth and clouds about the y-axis
  earth.rotation.y += .0005;
  clouds.rotation.y -= .00025;

  renderer.render(scene, camera);
  requestAnimationFrame(render);
};
render();
{% endhighlight %} 

Our graphic will now look as follows 

<div id="cloud-layer"></div>
<script>
  (function(){
    var width = window.innerWidth;
    var height = window.innerHeight;
    //Swap for mobile
    if (height > width) {
      var tempWidth = width;
      width = height;
      height = tempWidth;
    }
    var scene = new THREE.Scene();
    var camera = new THREE.PerspectiveCamera(45, width/height, 1, 2000);
    scene.add(camera);
    camera.position.set(0,0,30);

    var renderer = new THREE.WebGLRenderer({antialias: true});
    renderer.setSize(width/2, height/2);
    document.getElementById("cloud-layer").appendChild(renderer.domElement);

    var orbitControls = new THREE.OrbitControls(camera, renderer.domElement);

    var ambientLight = new THREE.AmbientLight(0xf1f1f1);
    scene.add(ambientLight);
    var spotLight = new THREE.DirectionalLight(0xffffff);
    spotLight.position.set(50,50,50);
    scene.add(spotLight);

    var earthGeometry = new THREE.SphereGeometry(10, 50, 50);
    var earthMaterial = new THREE.MeshPhongMaterial({
      map: new THREE.ImageUtils.loadTexture("/images/earth_3.jpg"),
      color: 0xf2f2f2,
      specular: 0xbbbbbb,
      shininess: 2
    });
    var earth = new THREE.Mesh(earthGeometry, earthMaterial);
    scene.add(earth);

    var cloudGeometry = new THREE.SphereGeometry(10.3,  50, 50);
    var cloudMaterial = new THREE.MeshPhongMaterial({
      map: new THREE.ImageUtils.loadTexture("/images/clouds_2.jpg"),
      transparent: true,
      opacity: 0.1
    });
    var clouds = new THREE.Mesh(cloudGeometry, cloudMaterial);
    scene.add(clouds);

    var render = function() {
      earth.rotation.y -= .0005;
      clouds.rotation.y -= .00025;
      renderer.render(scene, camera);
      requestAnimationFrame(render);
    };
    render();
  })();
</script> 

















